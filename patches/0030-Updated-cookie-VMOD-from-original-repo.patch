From 9d0b09961ff23315192ae5560c95f723ce26596d Mon Sep 17 00:00:00 2001
From: sorinrevsw <sorin.revsw@gmail.com>
Date: Tue, 30 Dec 2014 22:04:51 +0200
Subject: [PATCH 30/63] * Updated 'cookie' VMOD from original repo. * Fixed
 'chromelogger' VMOD for multithreaded use. * Added 'collect_partial' funtion
 to 'chromelogger' VMOD, to allow logging from 'vcl_backend_response'. *
 Removed empty 'revvar' VMOD init function.

---
 debian/changelog                                   |  10 +
 debian/rules                                       |  13 +-
 libvmod-chromelogger-4.0/README.rst                |   8 +-
 libvmod-chromelogger-4.0/src/vmod_chromelogger.c   | 178 +++++++++++++----
 libvmod-chromelogger-4.0/src/vmod_chromelogger.vcc |   4 +-
 libvmod-cookie-4.0/.gitignore                      |   1 +
 libvmod-cookie-4.0/README.rst                      |  28 +--
 libvmod-cookie-4.0/src/tests/07-isset.vtc          |  22 +--
 libvmod-cookie-4.0/src/tests/08-overflow.vtc       |  18 +-
 libvmod-cookie-4.0/src/tests/10-parser.vtc         |  26 +--
 libvmod-cookie-4.0/src/vmod_cookie.c               | 213 ++++++++++-----------
 libvmod-revvar-4.0/src/vmod_revvar.c               |   6 -
 libvmod-revvar-4.0/src/vmod_revvar.vcc             |   1 -
 13 files changed, 308 insertions(+), 220 deletions(-)

diff --git a/debian/changelog b/debian/changelog
index 58f1c49..d512f1e 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,13 @@
+revsw-varnish4-modules (0.5-2) unstable; urgency=medium
+
+  * Updated 'cookie' VMOD from original repo.
+  * Fixed 'chromelogger' VMOD for multithreaded use.
+  * Added 'collect_partial' funtion to 'chromelogger' VMOD, to allow
+    logging from 'vcl_backend_response'.
+  * Removed empty 'revvar' VMOD init function.
+
+ -- Sorin Otescu <sorin@revsw.com>  Tue, 30 Dec 2014 18:11:12 +0200
+
 revsw-varnish4-modules (0.5-1) unstable; urgency=medium
 
   * Fixed allocation for 'chromelogger' VMOD.
diff --git a/debian/rules b/debian/rules
index 6443b72..2dc36f3 100755
--- a/debian/rules
+++ b/debian/rules
@@ -5,12 +5,15 @@ VARNISHSRC := $(shell readlink -f ../varnish-4.0.2)
 VMODDIR := /usr/lib/varnish/vmods
 VMOD_ABI := $(shell printf '\#include "vmod_abi.h"\nVMOD_ABI_Version' | cpp - -I$(VARNISHSRC)/include | sed '/^\#/D;s/"//g;s/\([A-Z]\)/\L\1/g;s/[^a-z0-9.]/-/g;s/varnish/varnishabi/')
 
+#LOCAL_CFLAGS := -O0 -g3
+#LOCAL_LDFLAGS := -g3
+
 override_dh_auto_configure:
-	cd libvmod-chromelogger-4.0 && ./autogen.sh && ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
-	cd libvmod-cookie-4.0 && ./autogen.sh && ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
-	cd libvmod-revvar-4.0 && ./autogen.sh && ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
-	cd libvmod-header-4.0 && ./autogen.sh && ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
-	cd libvmod-timers-4.0 && ./autogen.sh && ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
+	cd libvmod-chromelogger-4.0 && ./autogen.sh && CFLAGS="$(LOCAL_CFLAGS)" LDFLAGS="$(LOCAL_LDFLAGS)" ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
+	cd libvmod-cookie-4.0 && ./autogen.sh && CFLAGS="$(LOCAL_CFLAGS)" LDFLAGS="$(LOCAL_LDFLAGS)" ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
+	cd libvmod-revvar-4.0 && ./autogen.sh && CFLAGS="$(LOCAL_CFLAGS)" LDFLAGS="$(LOCAL_LDFLAGS)" ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
+	cd libvmod-header-4.0 && ./autogen.sh && CFLAGS="$(LOCAL_CFLAGS)" LDFLAGS="$(LOCAL_LDFLAGS)" ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
+	cd libvmod-timers-4.0 && ./autogen.sh && CFLAGS="$(LOCAL_CFLAGS)" LDFLAGS="$(LOCAL_LDFLAGS)" ./configure --prefix=/usr --datarootdir=/usr/share --disable-static VMODDIR="$(VMODDIR)" VARNISHSRC="$(VARNISHSRC)"
 
 override_dh_gencontrol:
 	echo "Varnish:ABI=$(VMOD_ABI)" >> debian/substvars
diff --git a/libvmod-chromelogger-4.0/README.rst b/libvmod-chromelogger-4.0/README.rst
index 9c5fa26..fea606a 100644
--- a/libvmod-chromelogger-4.0/README.rst
+++ b/libvmod-chromelogger-4.0/README.rst
@@ -20,9 +20,15 @@ SYNOPSIS
                     chromelogger.log("So long, and thanks for all the fish");
                 }
 
+                sub vcl_backend_response {
+                    ### Collect backend-related entries into a temporary header
+                    set resp.http.X-ChromeLogger-BEData = chromelogger.collect_partial();
+                }
+
                 sub vcl_deliver {
                     ### Collect and encode all log entries
-                    set resp.http.X-ChromeLogger-Data = chromelogger.collect();
+                    set resp.http.X-ChromeLogger-Data = chromelogger.collect(resp.http.X-ChromeLogger-BEData);
+                    unset resp.http.X-ChromeLogger-BEData;
                 }
 
 
diff --git a/libvmod-chromelogger-4.0/src/vmod_chromelogger.c b/libvmod-chromelogger-4.0/src/vmod_chromelogger.c
index a4b6a30..6dde937 100644
--- a/libvmod-chromelogger-4.0/src/vmod_chromelogger.c
+++ b/libvmod-chromelogger-4.0/src/vmod_chromelogger.c
@@ -47,19 +47,85 @@ struct entry {
     enum type_e type;
 	VTAILQ_ENTRY(entry) list;
 };
-VTAILQ_HEAD(, entry) logentries = VTAILQ_HEAD_INITIALIZER(logentries);
 
-void vmod_VSB_quote_real(struct vsb *s, const char *p);
-void vmod_VSB_base64_encode(struct vsb *s, const char *p, ssize_t len);
+struct vmod_chromelogger {
+	unsigned magic;
+#define VMOD_CHROMELOGGER_MAGIC 0x4EF1FC23
+	unsigned xid;
+	VTAILQ_HEAD(, entry) logentries;
+};
+
+static pthread_key_t key;
+static pthread_once_t key_is_initialized = PTHREAD_ONCE_INIT;
+
+static void vmod_VSB_quote_real(struct vsb *s, const char *p);
+static void vmod_VSB_base64_encode(struct vsb *s, const char *p, ssize_t len);
+
+static void
+mkkey(void) {
+	AZ(pthread_key_create(&key, free));
+}
+
+int
+init_function(struct vmod_priv *priv, const struct VCL_conf *conf) {
+	pthread_once(&key_is_initialized, mkkey);
+	return (0);
+}
+
+static void
+clobj_clear(struct vmod_chromelogger *c) {
+	c->magic = VMOD_CHROMELOGGER_MAGIC;
+	VTAILQ_INIT(&c->logentries);
+	c->xid = 0;
+}
+
+static unsigned
+get_xid(const struct vrt_ctx *ctx) {
+    /*
+     * SORIN: don't use req->sp->vxid because it's not reliable (repeated values).
+     * Use the log wid instead (the "2" in "*   << Request  >> 2" in varnishlog).
+     */
+    if (ctx->req)
+        return ctx->req->vsl[0].wid;
+
+    AN(ctx->bo);
+    return ctx->bo->vsl->wid;
+}
+
+static struct vmod_chromelogger *
+clobj_get(const struct vrt_ctx *ctx) {
+	struct vmod_chromelogger *vcp = pthread_getspecific(key);
+
+	if (!vcp) {
+		vcp = malloc(sizeof *vcp);
+		AN(vcp);
+		clobj_clear(vcp);
+		vcp->xid = get_xid(ctx);
+		AZ(pthread_setspecific(key, vcp));
+	}
+
+	CHECK_OBJ_NOTNULL(vcp, VMOD_CHROMELOGGER_MAGIC);
+
+	if (vcp->xid != get_xid(ctx)) {
+		// Reuse previously allocated storage
+		clobj_clear(vcp);
+		vcp->xid = get_xid(ctx);
+	}
+
+	return (vcp);
+}
 
 /**
  * Add a new log message.
  */
 void
 vmod_log(const struct vrt_ctx *ctx, const char *s) {
+    struct vmod_chromelogger *vcp = clobj_get(ctx);
     int c;
     struct entry *newentry;
 
+    CHECK_OBJ_NOTNULL(vcp, VMOD_CHROMELOGGER_MAGIC);
+
         // Ignore empty lines
 	if (strlen(s) == 0)
 		return;
@@ -72,24 +138,40 @@ vmod_log(const struct vrt_ctx *ctx, const char *s) {
     strcpy(newentry->backtrace, "FIXME");
     newentry->type = LOG;
 
-	VTAILQ_INSERT_TAIL(&logentries, newentry, list);
+	VTAILQ_INSERT_TAIL(&vcp->logentries, newentry, list);
 }
 
-/**
- *
- */
-const char * __match_proto__()
-vmod_collect(const struct  vrt_ctx *ctx) {
+static void
+get_json_entries(struct vmod_chromelogger *vcp, struct vsb *json) {
     struct entry *e;
     struct entry *e2;
+
+    VTAILQ_FOREACH_SAFE(e, &vcp->logentries, list, e2) {
+        VSB_cat(json, "[[");
+        vmod_VSB_quote_real(json, e->data);
+        VSB_cat(json, "],");
+        vmod_VSB_quote_real(json, e->backtrace);
+        VSB_cat(json, ",\"");
+        VSB_cat(json, typeNames[e->type]);
+        VSB_cat(json, "\"],");
+        VTAILQ_REMOVE(&vcp->logentries, e, list);
+    }
+
+    // Remove last comma
+    json->s_len--;
+}
+
+const char * __match_proto__()
+vmod_collect(const struct vrt_ctx *ctx, VCL_STRING extra_json) {
+    struct vmod_chromelogger *vcp = clobj_get(ctx);
 	struct vsb *json;
 	struct vsb *output;
 	unsigned v, u;
 	char *p;
 
-	CHECK_OBJ_NOTNULL(ctx->req->sp, SESS_MAGIC);
+    CHECK_OBJ_NOTNULL(vcp, VMOD_CHROMELOGGER_MAGIC);
 
-    if (VTAILQ_EMPTY(&logentries))
+    if (VTAILQ_EMPTY(&vcp->logentries))
         return NULL;
 
 	u = WS_Reserve(ctx->ws, 0);
@@ -100,18 +182,13 @@ vmod_collect(const struct  vrt_ctx *ctx) {
 
 	VSB_cpy(json, "{\"version\": \"0.2\",\"columns\": [\"log\", \"backtrace\", \"type\"],\"rows\": [");
 
-	VTAILQ_FOREACH_SAFE(e, &logentries, list, e2) {
-		VSB_cat(json, "[[");
-		vmod_VSB_quote_real(json, e->data);
-		VSB_cat(json, "],");
-		vmod_VSB_quote_real(json, e->backtrace);
-		VSB_cat(json, ",\"");
-		VSB_cat(json, typeNames[e->type]);
-                VSB_cat(json, "\"],");
-		VTAILQ_REMOVE(&logentries, e, list);
-	}
-    // Remove last comma
-    json->s_len--;
+    get_json_entries(vcp, json);
+
+    if (extra_json && *extra_json) {
+        VSB_cat(json, ",");
+        VSB_cat(json, extra_json);
+    }
+
 	VSB_cat(json, "]}");
 	VSB_finish(json);
 
@@ -122,17 +199,54 @@ vmod_collect(const struct  vrt_ctx *ctx) {
     vmod_VSB_base64_encode(output, VSB_data(json), VSB_len(json));
 	VSB_finish(output);
 
-	v = VSB_len(output);
-	strcpy(p, VSB_data(output));
+	v = VSB_len(output) + 1;
+    if (v > u) {
+        /* Too big; roll back */
+        v = 0;
+        p = NULL;
+    }
+    else
+        strcpy(p, VSB_data(output));
 
 	VSB_delete(output);
 	VSB_delete(json);
 
-	v++;
-	if (v > u) {
-        WS_Release(ctx->ws, 0);
-        return (NULL);
-	}
+	WS_Release(ctx->ws, v);
+	return (p);
+}
+
+const char * __match_proto__()
+vmod_collect_partial(const struct vrt_ctx *ctx) {
+    struct vmod_chromelogger *vcp = clobj_get(ctx);
+	struct vsb *json;
+	unsigned v, u;
+	char *p;
+
+    CHECK_OBJ_NOTNULL(vcp, VMOD_CHROMELOGGER_MAGIC);
+
+    if (VTAILQ_EMPTY(&vcp->logentries))
+        return NULL;
+
+	u = WS_Reserve(ctx->ws, 0);
+	p = ctx->ws->f;
+
+	json = VSB_new_auto();
+	AN(json);
+
+    get_json_entries(vcp, json);
+	VSB_finish(json);
+
+	v = VSB_len(json) + 1;
+    if (v > u) {
+        /* Too big; roll back */
+        v = 0;
+        p = NULL;
+    }
+    else
+        strcpy(p, VSB_data(json));
+
+	VSB_delete(json);
+
 	WS_Release(ctx->ws, v);
 	return (p);
 }
@@ -140,7 +254,7 @@ vmod_collect(const struct  vrt_ctx *ctx) {
 /*
  * Quote a string
  */
-void
+static void
 vmod_VSB_quote_real(struct vsb *s, const char *p)
 {
 	const char *q;
@@ -177,7 +291,7 @@ vmod_VSB_quote_real(struct vsb *s, const char *p)
 	(void)VSB_putc(s, '"');
 }
 
-void
+static void
 vmod_VSB_base64_encode(struct vsb *s, const char *p, ssize_t len) {
     const static char* b64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
     ssize_t i;
diff --git a/libvmod-chromelogger-4.0/src/vmod_chromelogger.vcc b/libvmod-chromelogger-4.0/src/vmod_chromelogger.vcc
index f9d4cde..0da047e 100644
--- a/libvmod-chromelogger-4.0/src/vmod_chromelogger.vcc
+++ b/libvmod-chromelogger-4.0/src/vmod_chromelogger.vcc
@@ -1,3 +1,5 @@
 $Module chromelogger 3 Varnish chromelogger Module
+$Init init_function
 $Function VOID log(STRING)
-$Function STRING collect()
+$Function STRING collect(STRING)
+$Function STRING collect_partial()
diff --git a/libvmod-cookie-4.0/.gitignore b/libvmod-cookie-4.0/.gitignore
index ef77f6f..6df314e 100644
--- a/libvmod-cookie-4.0/.gitignore
+++ b/libvmod-cookie-4.0/.gitignore
@@ -28,3 +28,4 @@ Makefile.in
 
 /src/vcc_if.c
 /src/vcc_if.h
+/src/*rst
diff --git a/libvmod-cookie-4.0/README.rst b/libvmod-cookie-4.0/README.rst
index 612c784..c146afb 100644
--- a/libvmod-cookie-4.0/README.rst
+++ b/libvmod-cookie-4.0/README.rst
@@ -30,16 +30,15 @@ A convenience function for formatting the Set-Cookie Expires date field
 is also included. It might be needed to use libvmod-header if there might
 be multiple Set-Cookie response headers.
 
-This vmod allocates memory on the session workspace. It needs twice
-the memory requirement of your cookie string, usually less than 2KB.
-If you have many long cookies, or use other vmods that use the same memory
-segment, you might need to increase the sess_workspace parameter.
-
 Only within a single VMOD call is the state set by cookie.parse() /
 cookie.set() guaranteed to persist. This VMOD was designed to be used
 for cleaning up a request in vcl_recv, but works outside recv if needed.
 In such a case it is necessary to run cookie.parse() again.
 
+It is currently not safe/tested to call this VMOD in any fetch threads.
+Do the filtering in recv, fix up anything going in in deliver. Running it
+in vcl_backend_fetch and similar is untested and has undefined results.
+
 
 FUNCTIONS
 =========
@@ -248,20 +247,12 @@ using the varnishtest tool.
 
 Usage::
 
- ./configure VARNISHSRC=DIR [VMODDIR=DIR]
-
-`VARNISHSRC` is the directory of the Varnish source tree for which to
-compile your vmod. Both the `VARNISHSRC` and `VARNISHSRC/include`
-will be added to the include search paths for your module.
-
-Optionally you can also set the vmod install directory by adding
-`VMODDIR=DIR` (defaults to the pkg-config discovered directory from your
-Varnish installation).
+ ./configure --prefix=/usr
 
 Make targets:
 
 * make - builds the vmod
-* make install - installs the vmod in `VMODDIR`
+* make install - installs the vmod.
 * make check - runs the unit tests in ``src/tests/*.vtc``
 
 In your VCL you could then use this vmod along the following lines::
@@ -274,12 +265,6 @@ In your VCL you could then use this vmod along the following lines::
 	}
 
 
-HISTORY
-=======
-
-This manual page was released as part of the libvmod-example package,
-demonstrating how to create an out-of-tree Varnish vmod.
-
 COPYRIGHT
 =========
 
@@ -287,3 +272,4 @@ This document is licensed under the same license as the
 libvmod-example project. See LICENSE for details.
 
 * Copyright (c) 2011-2013 Varnish Software
+* Copyright (c) 2013-2014 Lasse Karstensen
diff --git a/libvmod-cookie-4.0/src/tests/07-isset.vtc b/libvmod-cookie-4.0/src/tests/07-isset.vtc
index 7160ada..c81792b 100644
--- a/libvmod-cookie-4.0/src/tests/07-isset.vtc
+++ b/libvmod-cookie-4.0/src/tests/07-isset.vtc
@@ -1,4 +1,4 @@
-varnishtest "Test cookie vmod"
+varnishtest "Test cookie.isset()"
 
 server s1 {
        rxreq
@@ -10,30 +10,18 @@ varnish v1 -vcl+backend {
 
 	sub vcl_recv {
 		cookie.set("cookie1", "cookie1value");
-		cookie.set("cookie2", "cookie2value");
 	}
 	sub vcl_deliver {
-		if (cookie.isset("cookie2")) {
-			set resp.http.X-foo = "ok";
-		}
-		else {
-			set resp.http.X-foo = "nok";
-		}
-
-		if (cookie.isset("non-existent")) {
-			set resp.http.X-bar = "nok";
-		}
-		else {
-			set resp.http.X-bar = "ok";
-		}
+		set resp.http.does = cookie.isset("cookie1");
+		set resp.http.does-not = cookie.isset("non-existent");
 	}
 } -start
 
 client c1 {
 	txreq -url "/"
 	rxresp
-	expect resp.http.X-foo == "ok"
-	expect resp.http.X-bar == "ok"
+	expect resp.http.does == "true"
+	expect resp.http.does-not == "false"
 }
 
 client c1 -run
diff --git a/libvmod-cookie-4.0/src/tests/08-overflow.vtc b/libvmod-cookie-4.0/src/tests/08-overflow.vtc
index d7bdc00..edcc8c7 100644
--- a/libvmod-cookie-4.0/src/tests/08-overflow.vtc
+++ b/libvmod-cookie-4.0/src/tests/08-overflow.vtc
@@ -12,25 +12,25 @@ varnish v1 -vcl+backend {
 	import cookie from "${vmod_topbuild}/src/.libs/libvmod_cookie.so";
 
 	sub vcl_recv {
-		cookie.parse(req.http.cookie);
 	}
 	sub vcl_deliver {
-		set resp.http.X-ok = cookie.get_string();
-		set resp.http.X-empty = cookie.isset("cookiename");
+		cookie.parse(req.http.cookie);
+		set resp.http.cookiestring = cookie.get_string();
+		set resp.http.cookie1 = cookie.isset("cookie1");
 	}
 } -start
 
 client c1 {
-	# insane cookie name, should be ignored.
+	# Insanely long cookie name. Should be ignored.
 	txreq -url "/" -hdr "Cookie: phohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1j=cookievalue"
 	rxresp
-	expect resp.http.X-ok == ""
+	expect resp.http.cookiestring == ""
 
-	# insane cookie value
-	txreq -url "/" -hdr "Cookie: cookiename=phohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1j"
+	# Insane 6KB cookie value.
+	txreq -url "/" -hdr "Cookie: cookie1=foobarbazfoobarbazphohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1jphohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1jphohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1jphohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1jphohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1jphohx8aingie6Ide7peephie5paip6ang4thooh4ooquai8ohvah7eiqueeki8ooth7viequ0Tha5thewiSheih5jaimaiTahr1wi8WooQuoe7loothieThahweeneichoo8cufeelu3tie5cei1iShiemiezoofox6ahcaevaihocheungai2aeghaichaingee0EiGie3Ees5ujaem5uquahpieFeelei7Ohngei1afaTooph4aiquum1aewaidatheshuh1fohhoor0hoo6aeTeiy9xougahf3jeapooshuhoob5deiwareingahth7ahf2fafeer8Oobiewai3rei8ofejohjeiye4die8Na7ze6eixajauCairoth0lek8vioyuom6eih0egho2aingoo7coh1at3niochu6osahthi0ue1Luchae1eifeupiuwaa0raidiewaijese4oozee4eihie5shaBaoreacooNg8uW9eru9kigh3Feesi8iex2pu7ohfaiBiezael6ifaujiek4nutae1aalohchoteiPuaM2chiefaicaopheKohsh6Ho1wiephieseef1daj3Pahfie2ooch8shaing5baXeiLiep9lahfe9uDaxeehielais2eix3iekiew8aiter9Foo8noo2hae7ohdie1iB7hoop3podeengooSothoojui4AhXu5Nain8ohqu8if1ue5iTheimei5oghie9sheiv4Hejah1veixahcaixie8ahyieT8Phay4daeTei1aRiemae6oicheef2miiNuoxeil1kae2nea1roh9Rei1keiwaT2eoJaiNgie0den6aideif3uechaishaec4cai2eozieb9aeN9sai9ahnielohdaeGh2kaeleiteitai0ietoo7eiCha0baiW7dai0im1jul5OWijaLo2ohh3kooxu2oFah3loob6feiw7pie9eighu8ik4chae0Athou2fah5ieQuuic0Mu1j;"
 	rxresp
-	# should not be set, since the name is invalid/overflowing.
-	expect resp.http.X-empty == "true"
+	# should not be set, since the cookie is overflowing 4KB.
+	expect resp.http.cookie1 == "false"
 }
 
 client c1 -run
diff --git a/libvmod-cookie-4.0/src/tests/10-parser.vtc b/libvmod-cookie-4.0/src/tests/10-parser.vtc
index 2187102..e7fc954 100644
--- a/libvmod-cookie-4.0/src/tests/10-parser.vtc
+++ b/libvmod-cookie-4.0/src/tests/10-parser.vtc
@@ -1,29 +1,14 @@
 varnishtest "Test cookie parser"
 
-server s1 {
+server s1 -repeat 5 {
        rxreq
        txresp
-
-       rxreq
-       txresp
-
-       rxreq
-       txresp
-
-       rxreq
-       txresp
-
 } -start
 
 varnish v1 -vcl+backend {
 	import cookie from "${vmod_topbuild}/src/.libs/libvmod_cookie.so";
-
-	sub vcl_recv {
- 		cookie.parse(req.http.cookie);
- 		cookie.parse(req.http.cookie);
- 		cookie.parse(req.http.cookie);
-	}
 	sub vcl_deliver {
+ 		cookie.parse(req.http.cookie);
 		set resp.http.X-foo = cookie.get_string();
 	}
 
@@ -53,3 +38,10 @@ client c4 {
 	rxresp
 	expect resp.http.X-foo == ""
 } -run
+
+# A single cookie should also work.
+client c5 {
+	txreq -hdr "Cookie: cookie1=foobarbaz"
+	rxresp
+	expect resp.http.X-foo == "cookie1=foobarbaz;"
+} -run
diff --git a/libvmod-cookie-4.0/src/vmod_cookie.c b/libvmod-cookie-4.0/src/vmod_cookie.c
index 8a8f9ea..bf343a2 100644
--- a/libvmod-cookie-4.0/src/vmod_cookie.c
+++ b/libvmod-cookie-4.0/src/vmod_cookie.c
@@ -10,13 +10,13 @@ Author: Lasse Karstensen <lasse@varnish-software.com>, July 2012.
 #include <stdio.h>
 
 #include "vrt.h"
+#include "vqueue.h"
 #include "cache/cache.h"
 
 #include "vcc_if.h"
 
-#define MAX_COOKIEPART 1024   /* name or value maxsize */
-#define MAX_COOKIESTRING 8196 /* cookie string maxlength */
-#define MAXCOOKIES 100
+#define MAX_COOKIE_NAME 1024   /* name maxsize */
+#define MAX_COOKIE_STRING 4096 /* cookie string maxlength */
 
 struct cookie {
 	char *name;
@@ -24,6 +24,11 @@ struct cookie {
 	VTAILQ_ENTRY(cookie) list;
 };
 
+struct whitelist {
+	char name[MAX_COOKIE_NAME];
+	VTAILQ_ENTRY(whitelist) list;
+};
+
 struct vmod_cookie {
 	unsigned magic;
 #define VMOD_COOKIE_MAGIC 0x4EE5FB2E
@@ -56,20 +61,28 @@ static struct vmod_cookie *
 cobj_get(const struct vrt_ctx *ctx) {
 	struct vmod_cookie *vcp = pthread_getspecific(key);
 
-	if (!vcp) {
+    /*
+     * SORIN: don't use req->sp->vxid because it's not reliable (repeated values).
+     * Use the log wid instead (the "2" in "*   << Request  >> 2" in varnishlog).
+     */
+
+    if (!vcp) {
 		vcp = malloc(sizeof *vcp);
 		AN(vcp);
 		cobj_clear(vcp);
-		vcp->xid = ctx->req->sp->vxid;
+		vcp->xid = ctx->req->vsl[0].wid;
 		AZ(pthread_setspecific(key, vcp));
+        VSLb(ctx->vsl, SLT_Debug, "cookie: new XID %u", vcp->xid);
 	}
 
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	if (vcp->xid != ctx->req->sp->vxid) {
+	if (vcp->xid != ctx->req->vsl[0].wid) {
+        VSLb(ctx->vsl, SLT_Debug, "cookie: reusing entry for XID %u; new XID %u",
+             vcp->xid, ctx->req->vsl[0].wid);
 		// Reuse previously allocated storage
 		cobj_clear(vcp);
-		vcp->xid = ctx->req->sp->vxid;
+		vcp->xid = ctx->req->vsl[0].wid;
 	}
 
 	return (vcp);
@@ -77,29 +90,29 @@ cobj_get(const struct vrt_ctx *ctx) {
 
 VCL_VOID
 vmod_parse(const struct vrt_ctx *ctx, VCL_STRING cookieheader) {
-	char tokendata[MAX_COOKIESTRING];
-	char *token, *tokstate, *key, *value, *sepindex;
-	char *dataptr = tokendata;
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	struct cookie *newcookie;
+	char tokendata[MAX_COOKIE_STRING];
+	char *token, *tokstate, *value, *sepindex, *dataptr;
 
 	int i = 0;
 
-	// If called twice during the same request, clean out old state
-	// before proceeding.
-	while (!VTAILQ_EMPTY(&vcp->cookielist)) {
-		newcookie = VTAILQ_FIRST(&vcp->cookielist);
-		VTAILQ_REMOVE(&vcp->cookielist, newcookie, list);
-	}
+    VSLb(ctx->vsl, SLT_Debug, "cookie: parse for XID %u", ctx->req->vsl[0].wid);
+    VSL_Flush(ctx->vsl, 0);
+
+    /* If called twice during the same request, clean out old state */
+	vmod_clean(ctx);
+
+	VSLb(ctx->vsl, SLT_Debug, "cookie: cookie string is %lu bytes.", strlen(cookieheader));
 
 	if (cookieheader == NULL || strlen(cookieheader) == 0) {
-		VSL(SLT_VCL_Log, 0, "cookie-vmod: nothing to parse");
+		VSLb(ctx->vsl, SLT_VCL_Log, "cookie: nothing to parse");
 		return;
+	}
 
-	if (strlen(cookieheader)+1 >= MAX_COOKIESTRING)
-		VSL(SLT_VCL_Log, 0, "cookie-vmod: cookie string overflowed, abort");
+	if (strlen(cookieheader) >= MAX_COOKIE_STRING) {
+		VSLb(ctx->vsl, SLT_VCL_Log, "cookie: cookie string overflowed, abort");
 		return;
 	}
 
@@ -111,44 +124,47 @@ vmod_parse(const struct vrt_ctx *ctx, VCL_STRING cookieheader) {
 		token = strtok_r(dataptr, ";", &tokstate);
 		dataptr = NULL; /* strtok() wants NULL on subsequent calls. */
 
-		if (token == NULL) break;
-		while (token[0] == ' ') token++;
-		//printf("token is: %s\n", token);
+		if (token == NULL)
+		    break;
+
+		while (token[0] == ' ')
+		    token++;
 
 		sepindex = strchr(token, '=');
 		if (sepindex == NULL) {
-			// could not find delimiter, this cookie is invalid. skip to the
-			// next (if any)
+			/* No delimiter, this cookie is invalid. Next! */
 			continue;
 		}
 		value = sepindex + 1;
 		*sepindex = '\0';
 
+		VSLb(ctx->vsl, SLT_Debug, "value length is %lu.", strlen(value));
 		vmod_set(ctx, token, value);
 		i++;
 	}
-
-	VSL(SLT_VCL_Log, 0, "libvmod-cookie: parsed %i cookies.", i);
+	VSLb(ctx->vsl, SLT_VCL_Log, "cookie: parsed %i cookies.", i);
 }
 
 
 VCL_VOID
 vmod_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value) {
-	struct cookie *newcookie;
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	// Empty cookies should be ignored.
+	AN(name);
+	AN(value);
+
+	/* Empty cookies should be ignored. */
 	if (strlen(name) == 0 || strlen(value) == 0) {
 		return;
 	}
 
-	if (strlen(name)+1 >= MAX_COOKIEPART) {
-		VSL(SLT_Debug, 0, "cookie-vmod: cookie string overflowed, abort");
+	if (strlen(name) + 1 >= MAX_COOKIE_NAME) {
+		VSLb(ctx->vsl, SLT_VCL_Log, "cookie: cookie string overflowed");
 		return;
 	}
-	struct cookie *cookie;
 
+	struct cookie *cookie;
 	VTAILQ_FOREACH(cookie, &vcp->cookielist, list) {
 		if (strcmp(cookie->name, name) == 0) {
 			cookie->value = WS_Printf(ctx->ws, "%s", value);
@@ -156,9 +172,9 @@ vmod_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value) {
 		}
 	}
 
-	newcookie = (struct cookie *) WS_Alloc(ctx->ws, sizeof(struct cookie));
+	struct cookie *newcookie = (struct cookie *)WS_Alloc(ctx->ws, sizeof(struct cookie));
 	if (newcookie == NULL) {
-		VSL(SLT_Debug, 0, "cookie-vmod: unable to get storage for cookie");
+		VSLb(ctx->vsl, SLT_VCL_Log, "cookie: unable to get storage for cookie");
 		return;
 	}
 	newcookie->name = WS_Printf(ctx->ws, "%s", name);
@@ -169,11 +185,11 @@ vmod_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value) {
 
 VCL_BOOL
 vmod_isset(const struct vrt_ctx *ctx, const char *name) {
-	struct cookie *cookie, *tmp;
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	VTAILQ_FOREACH_SAFE(cookie, &vcp->cookielist, list, tmp) {
+	struct cookie *cookie;
+	VTAILQ_FOREACH(cookie, &vcp->cookielist, list) {
 		if (strcmp(cookie->name, name) == 0) {
 			return 1;
 		}
@@ -183,11 +199,11 @@ vmod_isset(const struct vrt_ctx *ctx, const char *name) {
 
 VCL_STRING
 vmod_get(const struct vrt_ctx *ctx, VCL_STRING name) {
-	struct cookie *cookie, *tmp;
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	VTAILQ_FOREACH_SAFE(cookie, &vcp->cookielist, list, tmp) {
+	struct cookie *cookie;
+	VTAILQ_FOREACH(cookie, &vcp->cookielist, list) {
 		if (strcmp(cookie->name, name) == 0) {
 			return (cookie->value);
 		}
@@ -198,13 +214,14 @@ vmod_get(const struct vrt_ctx *ctx, VCL_STRING name) {
 
 VCL_VOID
 vmod_delete(const struct vrt_ctx *ctx, VCL_STRING name) {
-	struct cookie *cookie, *tmp;
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	VTAILQ_FOREACH_SAFE(cookie, &vcp->cookielist, list, tmp) {
+	struct cookie *cookie;
+	VTAILQ_FOREACH(cookie, &vcp->cookielist, list) {
 		if (strcmp(cookie->name, name) == 0) {
 			VTAILQ_REMOVE(&vcp->cookielist, cookie, list);
+			/* No way to clean up storage, let ws reclaim do it. */
 			break;
 		}
 	}
@@ -212,95 +229,73 @@ vmod_delete(const struct vrt_ctx *ctx, VCL_STRING name) {
 
 VCL_VOID
 vmod_clean(const struct vrt_ctx *ctx) {
-	struct cookie *cookie;
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	while (!VTAILQ_EMPTY(&vcp->cookielist)) {
-		cookie = VTAILQ_FIRST(&vcp->cookielist);
+	struct cookie *cookie, *c_safe;
+	VTAILQ_FOREACH_SAFE(cookie, &vcp->cookielist, list, c_safe) {
 		VTAILQ_REMOVE(&vcp->cookielist, cookie, list);
 	}
 }
 
-VCL_VOID
-vmod_filter_except(const struct vrt_ctx *ctx, VCL_STRING whitelist) {
-	char cookienames[MAX_COOKIEPART][MAXCOOKIES];
-	char tmpstr[MAX_COOKIESTRING];
-	struct cookie *cookie, *tmp;
+static VCL_VOID
+_filter_except_or_only(const struct vrt_ctx *ctx, VCL_STRING whitelist_s, VCL_BOOL except) {
+	char buf[MAX_COOKIE_STRING];
+	struct cookie *cookieptr;
 	char *tokptr, *saveptr;
-	int i, found = 0, num_cookies = 0;
+	int whitelisted = 0;
 	struct vmod_cookie *vcp = cobj_get(ctx);
+	struct whitelist *whentry;
+
+	VTAILQ_HEAD(, whitelist) whitelist_head;
+	VTAILQ_INIT(&whitelist_head);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	strcpy(tmpstr, whitelist);
-	tokptr = strtok_r(tmpstr, ",", &saveptr);
+	strcpy(buf, whitelist_s);
+	tokptr = strtok_r(buf, ",", &saveptr);
 	if (!tokptr) return;
 
-	// parse the whitelist.
+	/* Parse the supplied whitelist. */
 	while (1) {
-		strcpy(cookienames[num_cookies], tokptr);
-		num_cookies++;
-
+		whentry = malloc(sizeof(struct whitelist));
+		AN(whentry);
+		strcpy(whentry->name, tokptr);
+		VTAILQ_INSERT_TAIL(&whitelist_head, whentry, list);
 		tokptr = strtok_r(NULL, ",", &saveptr);
 		if (!tokptr) break;
 	}
 
-	// filter existing cookies that isn't in the whitelist.
-	VTAILQ_FOREACH_SAFE(cookie, &vcp->cookielist, list, tmp) {
-		found = 0;
-		for (i = 0; i < num_cookies; i++) {
-			if (strlen(cookie->name) == strlen(cookienames[i]) &&
-			    strcmp(cookienames[i], cookie->name) == 0) {
-				found = 1;
+	/* Filter existing cookies that isn't in the whitelist. */
+	VTAILQ_FOREACH(cookieptr, &vcp->cookielist, list) {
+		whitelisted = 0;
+		VTAILQ_FOREACH(whentry, &whitelist_head, list) {
+			if (strlen(cookieptr->name) == strlen(whentry->name) &&
+			    strcmp(cookieptr->name, whentry->name) == 0) {
+				whitelisted = 1;
 				break;
 			}
 		}
-
-		if (!found) {
-			VTAILQ_REMOVE(&vcp->cookielist, cookie, list);
+		if (except ^ whitelisted) {
+			VTAILQ_REMOVE(&vcp->cookielist, cookieptr, list);
 		}
-	} // foreach
+	}
+
+	VTAILQ_FOREACH(whentry, &whitelist_head, list) {
+		VTAILQ_REMOVE(&whitelist_head, whentry, list);
+		free(whentry);
+	}
 }
 
 
 VCL_VOID
-vmod_filter_only(const struct vrt_ctx *ctx, VCL_STRING blacklist) {
-        char cookienames[MAX_COOKIEPART][MAXCOOKIES];
-        char tmpstr[MAX_COOKIESTRING];
-        struct cookie *cookie, *tmp;
-        char *tokptr, *saveptr;
-        int i, found = 0, num_cookies = 0;
-        struct vmod_cookie *vcp = cobj_get(ctx);
-        CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
-
-        strcpy(tmpstr, (char *)blacklist);
-        tokptr = strtok_r(tmpstr, ",", &saveptr);
-        if (!tokptr) return;
-
-        // parse the blacklist.
-        while (1) {
-                strcpy(cookienames[num_cookies], tokptr);
-                num_cookies++;
-
-                tokptr = strtok_r(NULL, ",", &saveptr);
-                if (!tokptr) break;
-        }
-
-        // filter existing cookies that are in the blacklist.
-        VTAILQ_FOREACH_SAFE(cookie, &vcp->cookielist, list, tmp) {
-                found = 0;
-                for (i = 0; i < num_cookies; i++) {
-                        if (strlen(cookie->name) == strlen(cookienames[i]) &&
-                            strcmp(cookienames[i], cookie->name) == 0) {
-                                found = 1;
-                                break;
-                        }
-                }
-
-                if (found) {
-                        VTAILQ_REMOVE(&vcp->cookielist, cookie, list);
-                }
-        } // foreach
+vmod_filter_except(const struct vrt_ctx *ctx, VCL_STRING whitelist_s) {
+    _filter_except_or_only(ctx, whitelist_s, 1);
+}
+
+
+VCL_VOID
+vmod_filter_only(const struct vrt_ctx *ctx, VCL_STRING whitelist_s) {
+    _filter_except_or_only(ctx, whitelist_s, 0);
 }
 
 
@@ -313,9 +308,6 @@ vmod_get_string(const struct vrt_ctx *ctx) {
 	struct vmod_cookie *vcp = cobj_get(ctx);
 	CHECK_OBJ_NOTNULL(vcp, VMOD_COOKIE_MAGIC);
 
-	u = WS_Reserve(ctx->ws, 0);
-	p = ctx->ws->f;
-
 	output = VSB_new_auto();
 	AN(output);
 
@@ -324,19 +316,20 @@ vmod_get_string(const struct vrt_ctx *ctx) {
 	}
 	VSB_trim(output);
 	VSB_finish(output);
-	v = VSB_len(output);
+	v = 1 + VSB_len(output);
+
+	u = WS_Reserve(ctx->ws, 0);
+	p = ctx->ws->f;
 	strcpy(p, VSB_data(output));
 
 	VSB_delete(output);
 
-	v++;
 	if (v > u) {
 		WS_Release(ctx->ws, 0);
-		VSL(SLT_Debug, 0, "cookie-vmod: Workspace overflowed, abort");
+		VSLb(ctx->vsl, SLT_VCL_Log, "cookie: Workspace overflowed");
 		return (NULL);
 	}
 	WS_Release(ctx->ws, v);
-
 	return (p);
 }
 
diff --git a/libvmod-revvar-4.0/src/vmod_revvar.c b/libvmod-revvar-4.0/src/vmod_revvar.c
index b988c2e..d39c98d 100644
--- a/libvmod-revvar-4.0/src/vmod_revvar.c
+++ b/libvmod-revvar-4.0/src/vmod_revvar.c
@@ -73,12 +73,6 @@ _get_var(const struct vrt_ctx *ctx, VCL_BOOL from_req, VCL_INT idx)
 	return NULL;
 }
 
-int
-init_function(struct vmod_priv *priv, const struct VCL_conf *conf)
-{
-	return 0;
-}
-
 static struct var_array *
 _alloc_var_array(struct ws *ws, unsigned count, VCL_BOOL zero_out)
 {
diff --git a/libvmod-revvar-4.0/src/vmod_revvar.vcc b/libvmod-revvar-4.0/src/vmod_revvar.vcc
index d2e10f4..6f34242 100644
--- a/libvmod-revvar-4.0/src/vmod_revvar.vcc
+++ b/libvmod-revvar-4.0/src/vmod_revvar.vcc
@@ -1,5 +1,4 @@
 $Module revvar 3 RevSW Variable VMOD for Varnish
-$Init init_function
 
 # Set the number of variables to use
 $Function VOID init_var_count(INT)
-- 
2.7.4

