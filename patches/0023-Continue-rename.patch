From 19e5fb50fa0bc349d3739e52c116ecb8cea409f9 Mon Sep 17 00:00:00 2001
From: sorinrevsw <sorin.revsw@gmail.com>
Date: Sat, 27 Dec 2014 12:14:42 +0200
Subject: [PATCH 23/63] Continue rename.

---
 libvmod-revvar-4.0/configure.ac         |   2 +-
 libvmod-revvar-4.0/src/Makefile.am      |  14 +-
 libvmod-revvar-4.0/src/tests/test01.vtc |  28 +--
 libvmod-revvar-4.0/src/tests/test02.vtc |  12 +-
 libvmod-revvar-4.0/src/tests/test03.vtc |  32 +--
 libvmod-revvar-4.0/src/vmod_revvar.c    | 427 ++++++++++++++++++++++++++++++++
 libvmod-revvar-4.0/src/vmod_revvar.vcc  |  37 +++
 libvmod-revvar-4.0/src/vmod_var.c       | 427 --------------------------------
 libvmod-revvar-4.0/src/vmod_var.vcc     |  37 ---
 9 files changed, 508 insertions(+), 508 deletions(-)
 create mode 100644 libvmod-revvar-4.0/src/vmod_revvar.c
 create mode 100644 libvmod-revvar-4.0/src/vmod_revvar.vcc
 delete mode 100644 libvmod-revvar-4.0/src/vmod_var.c
 delete mode 100644 libvmod-revvar-4.0/src/vmod_var.vcc

diff --git a/libvmod-revvar-4.0/configure.ac b/libvmod-revvar-4.0/configure.ac
index a17a02b..e544712 100644
--- a/libvmod-revvar-4.0/configure.ac
+++ b/libvmod-revvar-4.0/configure.ac
@@ -2,7 +2,7 @@ AC_PREREQ(2.64)
 AC_COPYRIGHT([Copyright (c) 2011-2014 Varnish Software AS])
 AC_INIT([libvmod-var], [0.1])
 AC_CONFIG_MACRO_DIR([m4])
-AC_CONFIG_SRCDIR(src/vmod_var.vcc)
+AC_CONFIG_SRCDIR(src/vmod_revvar.vcc)
 AM_CONFIG_HEADER(config.h)
 
 AC_CANONICAL_SYSTEM
diff --git a/libvmod-revvar-4.0/src/Makefile.am b/libvmod-revvar-4.0/src/Makefile.am
index c57ec7c..bcf7453 100644
--- a/libvmod-revvar-4.0/src/Makefile.am
+++ b/libvmod-revvar-4.0/src/Makefile.am
@@ -1,17 +1,17 @@
 AM_CPPFLAGS = @VMOD_INCLUDES@
 
 vmoddir = @VMOD_DIR@
-vmod_LTLIBRARIES = libvmod_var.la
+vmod_LTLIBRARIES = libvmod_revvar.la
 
-libvmod_var_la_LDFLAGS = -module -export-dynamic -avoid-version -shared
+libvmod_revvar_la_LDFLAGS = -module -export-dynamic -avoid-version -shared
 
-libvmod_var_la_SOURCES = \
+libvmod_revvar_la_SOURCES = \
 	vcc_if.c \
 	vcc_if.h \
-	vmod_var.c
+	vmod_revvar.c
 
-vcc_if.c vcc_if.h: @VMODTOOL@ $(top_srcdir)/src/vmod_var.vcc
-	@VMODTOOL@ $(top_srcdir)/src/vmod_var.vcc
+vcc_if.c vcc_if.h: @VMODTOOL@ $(top_srcdir)/src/vmod_revvar.vcc
+	@VMODTOOL@ $(top_srcdir)/src/vmod_revvar.vcc
 
 VMOD_TESTS =  $(top_srcdir)/src/tests/*.vtc
 .PHONY: $(VMOD_TESTS)
@@ -22,7 +22,7 @@ $(top_srcdir)/src/tests/*.vtc:
 check: $(VMOD_TESTS)
 
 EXTRA_DIST = \
-	vmod_var.vcc \
+	vmod_revvar.vcc \
 	$(VMOD_TESTS)
 
 CLEANFILES = $(builddir)/vcc_if.c $(builddir)/vcc_if.h
\ No newline at end of file
diff --git a/libvmod-revvar-4.0/src/tests/test01.vtc b/libvmod-revvar-4.0/src/tests/test01.vtc
index f1c067a..b97689b 100644
--- a/libvmod-revvar-4.0/src/tests/test01.vtc
+++ b/libvmod-revvar-4.0/src/tests/test01.vtc
@@ -6,23 +6,23 @@ server s1 {
 } -start
 
 varnish v1 -vcl+backend {
-	import var from "${vmod_topbuild}/src/.libs/libvmod_var.so";
+	import revvar from "${vmod_topbuild}/src/.libs/libvmod_revvar.so";
 
 	sub vcl_deliver {
-		var.set("foo", "bar");
-		set resp.http.x-foo = var.get("foo");
-		var.set("foo2", "bar2");
-		set resp.http.x-foo = var.get("foo");
-		var.clear();
-		set resp.http.x-foo2 = "" + var.get("foo2");
-		var.set_int("i1", 123);
-		set resp.http.i1 = var.get_int("i1") + 1;
-		var.set_real("r1", 2);
-		var.set_real("r1", var.get_real("r1"));
-		set resp.http.r1 = var.get_real("r1");
+		revvar.set("foo", "bar");
+		set resp.http.x-foo = revvar.get("foo");
+		revvar.set("foo2", "bar2");
+		set resp.http.x-foo = revvar.get("foo");
+		revvar.clear();
+		set resp.http.x-foo2 = "" + revvar.get("foo2");
+		revvar.set_int("i1", 123);
+		set resp.http.i1 = revvar.get_int("i1") + 1;
+		revvar.set_real("r1", 2);
+		revvar.set_real("r1", revvar.get_real("r1"));
+		set resp.http.r1 = revvar.get_real("r1");
 
-		var.set_duration("d1", 1m);
-		set resp.http.d1 = var.get_duration("d1");
+		revvar.set_duration("d1", 1m);
+		set resp.http.d1 = revvar.get_duration("d1");
 	}
 } -start
 
diff --git a/libvmod-revvar-4.0/src/tests/test02.vtc b/libvmod-revvar-4.0/src/tests/test02.vtc
index ff3e6ae..dbd58cf 100644
--- a/libvmod-revvar-4.0/src/tests/test02.vtc
+++ b/libvmod-revvar-4.0/src/tests/test02.vtc
@@ -6,17 +6,17 @@ server s1 {
 } -start
 
 varnish v1 -vcl+backend {
-	import var from "${vmod_topbuild}/src/.libs/libvmod_var.so";
+	import revvar from "${vmod_topbuild}/src/.libs/libvmod_revvar.so";
 
 	sub vcl_init {
-		var.global_set("foo", "fooval");
-		var.global_set("bar", "barval");
-		var.global_set("bar", "altered_barval");
+		revvar.global_set("foo", "fooval");
+		revvar.global_set("bar", "barval");
+		revvar.global_set("bar", "altered_barval");
 	}
 
 	sub vcl_deliver {
-		set resp.http.x-foo = var.global_get("foo");
-		set resp.http.x-bar = var.global_get("bar");
+		set resp.http.x-foo = revvar.global_get("foo");
+		set resp.http.x-bar = revvar.global_get("bar");
 	}
 } -start
 
diff --git a/libvmod-revvar-4.0/src/tests/test03.vtc b/libvmod-revvar-4.0/src/tests/test03.vtc
index 2c17c94..a8f020b 100644
--- a/libvmod-revvar-4.0/src/tests/test03.vtc
+++ b/libvmod-revvar-4.0/src/tests/test03.vtc
@@ -6,25 +6,25 @@ server s1 {
 } -start
 
 varnish v1 -vcl+backend {
-	import var from "${vmod_topbuild}/src/.libs/libvmod_var.so";
+	import revvar from "${vmod_topbuild}/src/.libs/libvmod_revvar.so";
 
 	sub vcl_deliver {
-		var.set("foo", "bar");
-		set resp.http.x-foo = var.get("foo");
-		var.set("foo2", "bar2");
-		set resp.http.x-foo = var.get("foo");
-		var.clear();
-		set resp.http.x-foo2 = "" + var.get("foo2");
-		var.set_int("i1", 123);
-		set resp.http.i1 = var.get_int("i1") + 1;
-		var.set_real("r1", 2);
-		var.set_real("r1", var.get_real("r1"));
-		set resp.http.r1 = var.get_real("r1");
+		revvar.set("foo", "bar");
+		set resp.http.x-foo = revvar.get("foo");
+		revvar.set("foo2", "bar2");
+		set resp.http.x-foo = revvar.get("foo");
+		revvar.clear();
+		set resp.http.x-foo2 = "" + revvar.get("foo2");
+		revvar.set_int("i1", 123);
+		set resp.http.i1 = revvar.get_int("i1") + 1;
+		revvar.set_real("r1", 2);
+		revvar.set_real("r1", revvar.get_real("r1"));
+		set resp.http.r1 = revvar.get_real("r1");
 
-		var.set_duration("d1", 1m);
-		set resp.http.d1 = var.get_duration("d1");
-		set resp.http.x-null = var.get("nosuchvar");
-		set resp.http.x-null2 = var.get(req.http.no-such-var);
+		revvar.set_duration("d1", 1m);
+		set resp.http.d1 = revvar.get_duration("d1");
+		set resp.http.x-null = revvar.get("nosuchvar");
+		set resp.http.x-null2 = revvar.get(req.http.no-such-var);
 	}
 } -start
 
diff --git a/libvmod-revvar-4.0/src/vmod_revvar.c b/libvmod-revvar-4.0/src/vmod_revvar.c
new file mode 100644
index 0000000..7161aee
--- /dev/null
+++ b/libvmod-revvar-4.0/src/vmod_revvar.c
@@ -0,0 +1,427 @@
+#include <stdlib.h>
+#include <ctype.h>
+
+#include "vrt.h"
+#include "cache/cache.h"
+
+#include "vcc_if.h"
+
+enum VAR_TYPE {
+	UNSET,
+	STRING,
+	INT,
+	REAL,
+	DURATION,
+	BOOL
+};
+
+struct var {
+	unsigned magic;
+#define VAR_MAGIC 0x8A21A651
+	char *name;
+	enum VAR_TYPE type;
+	union {
+		char *STRING;
+		int INT;
+		unsigned BOOL;
+		double REAL;
+		double DURATION;
+	} value;
+	VTAILQ_ENTRY(var) list;
+};
+
+struct var_head {
+	unsigned magic;
+#define VAR_HEAD_MAGIC 0x64F33E2F
+	uint32_t vxid;
+	VTAILQ_HEAD(, var) vars;
+};
+
+static struct var_head **var_list = NULL;
+static int var_list_sz = 0;
+static VTAILQ_HEAD(, var) global_vars = VTAILQ_HEAD_INITIALIZER(global_vars);
+static pthread_mutex_t var_list_mtx = PTHREAD_MUTEX_INITIALIZER;
+
+static void
+vh_init(struct var_head *vh)
+{
+
+	AN(vh);
+	memset(vh, 0, sizeof *vh);
+	vh->magic = VAR_HEAD_MAGIC;
+	VTAILQ_INIT(&vh->vars);
+}
+
+static struct var *
+vh_get_var(struct var_head *vh, const char *name)
+{
+	struct var *v;
+
+	AN(vh);
+	AN(name);
+	VTAILQ_FOREACH(v, &vh->vars, list) {
+		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);
+		AN(v->name);
+		if (strcmp(v->name, name) == 0)
+			return v;
+	}
+	return NULL;
+}
+
+
+static struct var *
+vh_get_var_alloc(struct var_head *vh, const char *name, const struct vrt_ctx *ctx)
+{
+	struct var *v;
+
+	v = vh_get_var(vh, name);
+	if (!v)
+	{
+		/* Allocate and add */
+		v = (struct var*)WS_Alloc(ctx->ws, sizeof(struct var));
+		AN(v);
+		v->magic = VAR_MAGIC;
+		v->name = WS_Copy(ctx->ws, name, -1);
+		AN(v->name);
+		VTAILQ_INSERT_HEAD(&vh->vars, v, list);
+	}
+	return v;
+}
+
+int
+init_function(struct vmod_priv *priv, const struct VCL_conf *conf)
+{
+
+	AZ(pthread_mutex_lock(&var_list_mtx));
+	if (var_list == NULL) {
+		AZ(var_list_sz);
+		var_list_sz = 256;
+		var_list = malloc(sizeof(struct var_head *) * 256);
+		AN(var_list);
+		for (int i = 0 ; i < var_list_sz; i++) {
+			var_list[i] = malloc(sizeof(struct var_head));
+			vh_init(var_list[i]);
+		}
+	}
+	AZ(pthread_mutex_unlock(&var_list_mtx));
+	return 0;
+}
+
+static struct var_head *
+get_vh(const struct vrt_ctx *ctx)
+{
+	struct var_head *vh;
+
+	AZ(pthread_mutex_lock(&var_list_mtx));
+	while (var_list_sz <= ctx->req->sp->fd) {
+		int ns = var_list_sz*2;
+		/* resize array */
+		var_list = realloc(var_list, ns * sizeof(struct var_head *));
+		for (; var_list_sz < ns; var_list_sz++) {
+			var_list[var_list_sz] = malloc(sizeof(struct var_head));
+			vh_init(var_list[var_list_sz]);
+		}
+		assert(var_list_sz == ns);
+		AN(var_list);
+	}
+	vh = var_list[ctx->req->sp->fd];
+
+	if (vh->vxid != ctx->req->sp->vxid) {
+		vh_init(vh);
+		vh->vxid = ctx->req->sp->vxid;
+	}
+	AZ(pthread_mutex_unlock(&var_list_mtx));
+	return vh;
+}
+
+VCL_VOID
+vmod_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
+{
+	vmod_set_string(ctx, name, value);
+}
+
+VCL_STRING
+vmod_get(const struct vrt_ctx *ctx, VCL_STRING name)
+{
+	return vmod_get_string(ctx, name);
+}
+
+VCL_VOID
+vmod_unset(const struct vrt_ctx *ctx, VCL_STRING name)
+{
+    struct var *v;
+    if (name == NULL)
+        return;
+    v = vh_get_var(get_vh(ctx), name);
+
+}
+
+VCL_VOID
+vmod_set_string(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
+{
+	struct var *v;
+
+	if (name == NULL)
+		return;
+	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
+	AN(v);
+	v->type = STRING;
+	if (value == NULL)
+		value = "";
+	v->value.STRING = WS_Copy(ctx->ws, value, -1);
+}
+
+VCL_VOID
+vmod_set_string_allow_null(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
+{
+	struct var *v;
+
+	if (name == NULL)
+		return;
+	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
+	AN(v);
+
+    if (value) {
+        v->type = STRING;
+        v->value.STRING = WS_Copy(ctx->ws, value, -1);
+    }
+}
+
+VCL_VOID
+vmod_set_string_literal(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
+{
+	struct var *v;
+
+	if (name == NULL)
+		return;
+	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
+	AN(v);
+
+	v->type = STRING;
+	if (value == NULL)
+		value = "";
+    /* 'value' is a constant, literal string which is "allocated" at compile time.
+     * Don't need to dup it.
+     */
+	v->value.STRING = (char *)value;
+}
+VCL_STRING
+vmod_get_string(const struct vrt_ctx *ctx, VCL_STRING name)
+{
+	struct var *v;
+	if (name == NULL)
+		return (NULL);
+	v = vh_get_var(get_vh(ctx), name);
+	if (!v || v->type != STRING)
+		return NULL;
+	return (v->value.STRING);
+}
+
+
+#define VMOD_SET_X(vcl_type_u, vcl_type_l, ctype) \
+VCL_VOID \
+vmod_set_##vcl_type_l(const struct vrt_ctx *ctx, const char *name, ctype value) \
+{ \
+	struct var *v; \
+	if (name == NULL) \
+		return; \
+	v = vh_get_var_alloc(get_vh(ctx), name, ctx); \
+	AN(v); \
+	v->type = vcl_type_u; \
+	v->value.vcl_type_u = value; \
+}
+
+VMOD_SET_X(INT, int, VCL_INT)
+VMOD_SET_X(REAL, real, VCL_REAL)
+VMOD_SET_X(DURATION, duration, VCL_DURATION)
+VMOD_SET_X(BOOL, bool, VCL_BOOL)
+
+#define VMOD_GET_X(vcl_type_u, vcl_type_l, ctype) \
+ctype \
+vmod_get_##vcl_type_l(const struct vrt_ctx *ctx, const char *name) \
+{ \
+	struct var *v; \
+\
+	if (name == NULL) \
+		return 0; \
+	v = vh_get_var(get_vh(ctx), name); \
+\
+	if (!v || v->type != vcl_type_u) \
+		return 0; \
+	return (v->value.vcl_type_u); \
+}
+
+VMOD_GET_X(INT, int, VCL_INT)
+VMOD_GET_X(REAL, real, VCL_REAL)
+VMOD_GET_X(DURATION, duration, VCL_DURATION)
+VMOD_GET_X(BOOL, bool, VCL_BOOL)
+
+VCL_BOOL
+vmod_and_or_set_bool(const struct vrt_ctx *ctx, VCL_STRING name, VCL_BOOL value)
+{
+	struct var *v;
+	if (name == NULL)
+		return 0;
+	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
+	if (!v) {
+
+		AN(v);
+
+		v->type = BOOL;
+		v->value.BOOL = value;
+	} else {
+		if (v->type != BOOL)
+			return 0;
+		v->value.BOOL = v->value.BOOL && value;
+	}
+	return v->value.BOOL;
+}
+
+VCL_BOOL
+vmod_or_or_set_bool(const struct vrt_ctx *ctx, VCL_STRING name, VCL_BOOL value)
+{
+	struct var *v;
+	if (name == NULL)
+		return 0;
+	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
+	if (!v) {
+
+		AN(v);
+
+		v->type = BOOL;
+		v->value.BOOL = value;
+	} else {
+		if (v->type != BOOL)
+			return 0;
+		v->value.BOOL = v->value.BOOL || value;
+	}
+	return v->value.BOOL;
+}
+
+VCL_VOID
+vmod_clear(const struct vrt_ctx *ctx)
+{
+	struct var_head *vh;
+	vh = get_vh(ctx);
+	vh_init(vh);
+}
+
+VCL_VOID
+vmod_global_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
+{
+	struct var *v;
+
+	if (name == NULL)
+		return;
+
+	AZ(pthread_mutex_lock(&var_list_mtx));
+	VTAILQ_FOREACH(v, &global_vars, list) {
+		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);
+		AN(v->name);
+		if (strcmp(v->name, name) == 0)
+			break;
+	}
+	if (v) {
+		VTAILQ_REMOVE(&global_vars, v, list);
+		free(v->name);
+		v->name = NULL;
+	} else
+		ALLOC_OBJ(v, VAR_MAGIC);
+	AN(v);
+	v->name = strdup(name);
+	AN(v->name);
+	VTAILQ_INSERT_HEAD(&global_vars, v, list);
+	if (v->type == STRING)
+		free(v->value.STRING);
+	v->value.STRING = NULL;
+	v->type = STRING;
+	if (value != NULL)
+		v->value.STRING = strdup(value);
+
+	AZ(pthread_mutex_unlock(&var_list_mtx));
+}
+
+VCL_STRING
+vmod_global_get(const struct vrt_ctx *ctx, VCL_STRING name)
+{
+	struct var *v;
+	const char *r = NULL;
+
+	AZ(pthread_mutex_lock(&var_list_mtx));
+	VTAILQ_FOREACH(v, &global_vars, list) {
+		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);
+		AN(v->name);
+		if (strcmp(v->name, name) == 0)
+			break;
+	}
+	if (v && v->value.STRING != NULL) {
+		r = WS_Copy(ctx->ws, v->value.STRING, -1);
+		AN(r);
+	}
+	AZ(pthread_mutex_unlock(&var_list_mtx));
+	return(r);
+}
+
+#define VMOD_GLOBAL_SET_X(vcl_type_u, vcl_type_l, ctype)			    \
+void									                                \
+vmod_global_set_##vcl_type_l(const struct vrt_ctx *ctx, const char *name, ctype value)	\
+{									                                    \
+	struct var *v;				                                        \
+	if (name == NULL)				                                    \
+		return;				                                            \
+	AZ(pthread_mutex_lock(&var_list_mtx));				                \
+	VTAILQ_FOREACH(v, &global_vars, list) {				                \
+		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);				                \
+		AN(v->name);				                                    \
+		if (strcmp(v->name, name) == 0)				                    \
+			break;				                                        \
+	}				                                                    \
+	if (v) {				                                            \
+		VTAILQ_REMOVE(&global_vars, v, list);				            \
+		free(v->name);				                                    \
+		v->name = NULL;				                                    \
+	} else				                                                \
+		ALLOC_OBJ(v, VAR_MAGIC);				                        \
+	AN(v);				                                                \
+	v->name = strdup(name);				                                \
+	AN(v->name);				                                        \
+	VTAILQ_INSERT_HEAD(&global_vars, v, list);				            \
+	if (v->type == STRING)				                                \
+		free(v->value.STRING);				                            \
+	v->value.vcl_type_u = value;				                        \
+	v->type = vcl_type_u;				                                \
+	AZ(pthread_mutex_unlock(&var_list_mtx));				            \
+}
+
+VMOD_GLOBAL_SET_X(INT, int, VCL_INT)
+VMOD_GLOBAL_SET_X(REAL, real, VCL_REAL)
+VMOD_GLOBAL_SET_X(DURATION, duration, VCL_DURATION)
+VMOD_GLOBAL_SET_X(BOOL, bool, VCL_BOOL)
+
+#define VMOD_GLOBAL_GET_X(vcl_type_u, vcl_type_l, ctype)			    \
+ctype									                        \
+vmod_global_get_##vcl_type_l(const struct vrt_ctx *ctx, const char *name)	\
+{									                            \
+	struct var *v;							                    \
+	ctype ret = 0;					                            \
+	if (name == NULL)						                    \
+		return (0);						                        \
+	AZ(pthread_mutex_lock(&var_list_mtx));                      \
+	VTAILQ_FOREACH(v, &global_vars, list) {                     \
+		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);                        \
+		AN(v->name);                                            \
+		if (strcmp(v->name, name) == 0)                         \
+			break;                                              \
+	}                                                           \
+									                            \
+	if (v && v->type == vcl_type_u) 				            \
+		ret = v->value.vcl_type_u;                              \
+    AZ(pthread_mutex_unlock(&var_list_mtx));                    \
+	return ret;					                                \
+}
+
+VMOD_GLOBAL_GET_X(INT, int, VCL_INT)
+VMOD_GLOBAL_GET_X(REAL, real, VCL_REAL)
+VMOD_GLOBAL_GET_X(DURATION, duration, VCL_DURATION)
+VMOD_GLOBAL_GET_X(BOOL, bool, VCL_BOOL)
+
diff --git a/libvmod-revvar-4.0/src/vmod_revvar.vcc b/libvmod-revvar-4.0/src/vmod_revvar.vcc
new file mode 100644
index 0000000..6261008
--- /dev/null
+++ b/libvmod-revvar-4.0/src/vmod_revvar.vcc
@@ -0,0 +1,37 @@
+$Module var 3 Variable VMOD for Varnish
+$Init init_function
+# Shortcut for strings
+$Function VOID set(STRING, STRING)
+$Function STRING get(STRING)
+
+# Unset for any
+$Function VOID unset(STRING)
+
+$Function VOID global_set(STRING, STRING)
+$Function STRING global_get(STRING)
+
+$Function VOID global_set_int(STRING, INT)
+$Function INT global_get_int(STRING)
+$Function VOID global_set_real(STRING, REAL)
+$Function REAL global_get_real(STRING)
+$Function VOID global_set_duration(STRING, DURATION)
+$Function DURATION global_get_duration(STRING)
+$Function VOID global_set_bool(STRING, BOOL)
+$Function BOOL global_get_bool(STRING)
+
+$Function VOID set_int(STRING, INT)
+$Function INT get_int(STRING)
+$Function VOID set_string(STRING, STRING)
+$Function VOID set_string_allow_null(STRING, STRING)
+$Function VOID set_string_literal(STRING, STRING)
+$Function STRING get_string(STRING)
+$Function VOID set_real(STRING, REAL)
+$Function REAL get_real(STRING)
+$Function VOID set_duration(STRING, DURATION)
+$Function DURATION get_duration(STRING)
+$Function VOID set_bool(STRING, BOOL)
+$Function BOOL get_bool(STRING)
+$Function BOOL and_or_set_bool(STRING, BOOL)
+$Function BOOL or_or_set_bool(STRING, BOOL)
+
+$Function VOID clear()
diff --git a/libvmod-revvar-4.0/src/vmod_var.c b/libvmod-revvar-4.0/src/vmod_var.c
deleted file mode 100644
index 7161aee..0000000
--- a/libvmod-revvar-4.0/src/vmod_var.c
+++ /dev/null
@@ -1,427 +0,0 @@
-#include <stdlib.h>
-#include <ctype.h>
-
-#include "vrt.h"
-#include "cache/cache.h"
-
-#include "vcc_if.h"
-
-enum VAR_TYPE {
-	UNSET,
-	STRING,
-	INT,
-	REAL,
-	DURATION,
-	BOOL
-};
-
-struct var {
-	unsigned magic;
-#define VAR_MAGIC 0x8A21A651
-	char *name;
-	enum VAR_TYPE type;
-	union {
-		char *STRING;
-		int INT;
-		unsigned BOOL;
-		double REAL;
-		double DURATION;
-	} value;
-	VTAILQ_ENTRY(var) list;
-};
-
-struct var_head {
-	unsigned magic;
-#define VAR_HEAD_MAGIC 0x64F33E2F
-	uint32_t vxid;
-	VTAILQ_HEAD(, var) vars;
-};
-
-static struct var_head **var_list = NULL;
-static int var_list_sz = 0;
-static VTAILQ_HEAD(, var) global_vars = VTAILQ_HEAD_INITIALIZER(global_vars);
-static pthread_mutex_t var_list_mtx = PTHREAD_MUTEX_INITIALIZER;
-
-static void
-vh_init(struct var_head *vh)
-{
-
-	AN(vh);
-	memset(vh, 0, sizeof *vh);
-	vh->magic = VAR_HEAD_MAGIC;
-	VTAILQ_INIT(&vh->vars);
-}
-
-static struct var *
-vh_get_var(struct var_head *vh, const char *name)
-{
-	struct var *v;
-
-	AN(vh);
-	AN(name);
-	VTAILQ_FOREACH(v, &vh->vars, list) {
-		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);
-		AN(v->name);
-		if (strcmp(v->name, name) == 0)
-			return v;
-	}
-	return NULL;
-}
-
-
-static struct var *
-vh_get_var_alloc(struct var_head *vh, const char *name, const struct vrt_ctx *ctx)
-{
-	struct var *v;
-
-	v = vh_get_var(vh, name);
-	if (!v)
-	{
-		/* Allocate and add */
-		v = (struct var*)WS_Alloc(ctx->ws, sizeof(struct var));
-		AN(v);
-		v->magic = VAR_MAGIC;
-		v->name = WS_Copy(ctx->ws, name, -1);
-		AN(v->name);
-		VTAILQ_INSERT_HEAD(&vh->vars, v, list);
-	}
-	return v;
-}
-
-int
-init_function(struct vmod_priv *priv, const struct VCL_conf *conf)
-{
-
-	AZ(pthread_mutex_lock(&var_list_mtx));
-	if (var_list == NULL) {
-		AZ(var_list_sz);
-		var_list_sz = 256;
-		var_list = malloc(sizeof(struct var_head *) * 256);
-		AN(var_list);
-		for (int i = 0 ; i < var_list_sz; i++) {
-			var_list[i] = malloc(sizeof(struct var_head));
-			vh_init(var_list[i]);
-		}
-	}
-	AZ(pthread_mutex_unlock(&var_list_mtx));
-	return 0;
-}
-
-static struct var_head *
-get_vh(const struct vrt_ctx *ctx)
-{
-	struct var_head *vh;
-
-	AZ(pthread_mutex_lock(&var_list_mtx));
-	while (var_list_sz <= ctx->req->sp->fd) {
-		int ns = var_list_sz*2;
-		/* resize array */
-		var_list = realloc(var_list, ns * sizeof(struct var_head *));
-		for (; var_list_sz < ns; var_list_sz++) {
-			var_list[var_list_sz] = malloc(sizeof(struct var_head));
-			vh_init(var_list[var_list_sz]);
-		}
-		assert(var_list_sz == ns);
-		AN(var_list);
-	}
-	vh = var_list[ctx->req->sp->fd];
-
-	if (vh->vxid != ctx->req->sp->vxid) {
-		vh_init(vh);
-		vh->vxid = ctx->req->sp->vxid;
-	}
-	AZ(pthread_mutex_unlock(&var_list_mtx));
-	return vh;
-}
-
-VCL_VOID
-vmod_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
-{
-	vmod_set_string(ctx, name, value);
-}
-
-VCL_STRING
-vmod_get(const struct vrt_ctx *ctx, VCL_STRING name)
-{
-	return vmod_get_string(ctx, name);
-}
-
-VCL_VOID
-vmod_unset(const struct vrt_ctx *ctx, VCL_STRING name)
-{
-    struct var *v;
-    if (name == NULL)
-        return;
-    v = vh_get_var(get_vh(ctx), name);
-
-}
-
-VCL_VOID
-vmod_set_string(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
-{
-	struct var *v;
-
-	if (name == NULL)
-		return;
-	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
-	AN(v);
-	v->type = STRING;
-	if (value == NULL)
-		value = "";
-	v->value.STRING = WS_Copy(ctx->ws, value, -1);
-}
-
-VCL_VOID
-vmod_set_string_allow_null(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
-{
-	struct var *v;
-
-	if (name == NULL)
-		return;
-	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
-	AN(v);
-
-    if (value) {
-        v->type = STRING;
-        v->value.STRING = WS_Copy(ctx->ws, value, -1);
-    }
-}
-
-VCL_VOID
-vmod_set_string_literal(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
-{
-	struct var *v;
-
-	if (name == NULL)
-		return;
-	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
-	AN(v);
-
-	v->type = STRING;
-	if (value == NULL)
-		value = "";
-    /* 'value' is a constant, literal string which is "allocated" at compile time.
-     * Don't need to dup it.
-     */
-	v->value.STRING = (char *)value;
-}
-VCL_STRING
-vmod_get_string(const struct vrt_ctx *ctx, VCL_STRING name)
-{
-	struct var *v;
-	if (name == NULL)
-		return (NULL);
-	v = vh_get_var(get_vh(ctx), name);
-	if (!v || v->type != STRING)
-		return NULL;
-	return (v->value.STRING);
-}
-
-
-#define VMOD_SET_X(vcl_type_u, vcl_type_l, ctype) \
-VCL_VOID \
-vmod_set_##vcl_type_l(const struct vrt_ctx *ctx, const char *name, ctype value) \
-{ \
-	struct var *v; \
-	if (name == NULL) \
-		return; \
-	v = vh_get_var_alloc(get_vh(ctx), name, ctx); \
-	AN(v); \
-	v->type = vcl_type_u; \
-	v->value.vcl_type_u = value; \
-}
-
-VMOD_SET_X(INT, int, VCL_INT)
-VMOD_SET_X(REAL, real, VCL_REAL)
-VMOD_SET_X(DURATION, duration, VCL_DURATION)
-VMOD_SET_X(BOOL, bool, VCL_BOOL)
-
-#define VMOD_GET_X(vcl_type_u, vcl_type_l, ctype) \
-ctype \
-vmod_get_##vcl_type_l(const struct vrt_ctx *ctx, const char *name) \
-{ \
-	struct var *v; \
-\
-	if (name == NULL) \
-		return 0; \
-	v = vh_get_var(get_vh(ctx), name); \
-\
-	if (!v || v->type != vcl_type_u) \
-		return 0; \
-	return (v->value.vcl_type_u); \
-}
-
-VMOD_GET_X(INT, int, VCL_INT)
-VMOD_GET_X(REAL, real, VCL_REAL)
-VMOD_GET_X(DURATION, duration, VCL_DURATION)
-VMOD_GET_X(BOOL, bool, VCL_BOOL)
-
-VCL_BOOL
-vmod_and_or_set_bool(const struct vrt_ctx *ctx, VCL_STRING name, VCL_BOOL value)
-{
-	struct var *v;
-	if (name == NULL)
-		return 0;
-	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
-	if (!v) {
-
-		AN(v);
-
-		v->type = BOOL;
-		v->value.BOOL = value;
-	} else {
-		if (v->type != BOOL)
-			return 0;
-		v->value.BOOL = v->value.BOOL && value;
-	}
-	return v->value.BOOL;
-}
-
-VCL_BOOL
-vmod_or_or_set_bool(const struct vrt_ctx *ctx, VCL_STRING name, VCL_BOOL value)
-{
-	struct var *v;
-	if (name == NULL)
-		return 0;
-	v = vh_get_var_alloc(get_vh(ctx), name, ctx);
-	if (!v) {
-
-		AN(v);
-
-		v->type = BOOL;
-		v->value.BOOL = value;
-	} else {
-		if (v->type != BOOL)
-			return 0;
-		v->value.BOOL = v->value.BOOL || value;
-	}
-	return v->value.BOOL;
-}
-
-VCL_VOID
-vmod_clear(const struct vrt_ctx *ctx)
-{
-	struct var_head *vh;
-	vh = get_vh(ctx);
-	vh_init(vh);
-}
-
-VCL_VOID
-vmod_global_set(const struct vrt_ctx *ctx, VCL_STRING name, VCL_STRING value)
-{
-	struct var *v;
-
-	if (name == NULL)
-		return;
-
-	AZ(pthread_mutex_lock(&var_list_mtx));
-	VTAILQ_FOREACH(v, &global_vars, list) {
-		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);
-		AN(v->name);
-		if (strcmp(v->name, name) == 0)
-			break;
-	}
-	if (v) {
-		VTAILQ_REMOVE(&global_vars, v, list);
-		free(v->name);
-		v->name = NULL;
-	} else
-		ALLOC_OBJ(v, VAR_MAGIC);
-	AN(v);
-	v->name = strdup(name);
-	AN(v->name);
-	VTAILQ_INSERT_HEAD(&global_vars, v, list);
-	if (v->type == STRING)
-		free(v->value.STRING);
-	v->value.STRING = NULL;
-	v->type = STRING;
-	if (value != NULL)
-		v->value.STRING = strdup(value);
-
-	AZ(pthread_mutex_unlock(&var_list_mtx));
-}
-
-VCL_STRING
-vmod_global_get(const struct vrt_ctx *ctx, VCL_STRING name)
-{
-	struct var *v;
-	const char *r = NULL;
-
-	AZ(pthread_mutex_lock(&var_list_mtx));
-	VTAILQ_FOREACH(v, &global_vars, list) {
-		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);
-		AN(v->name);
-		if (strcmp(v->name, name) == 0)
-			break;
-	}
-	if (v && v->value.STRING != NULL) {
-		r = WS_Copy(ctx->ws, v->value.STRING, -1);
-		AN(r);
-	}
-	AZ(pthread_mutex_unlock(&var_list_mtx));
-	return(r);
-}
-
-#define VMOD_GLOBAL_SET_X(vcl_type_u, vcl_type_l, ctype)			    \
-void									                                \
-vmod_global_set_##vcl_type_l(const struct vrt_ctx *ctx, const char *name, ctype value)	\
-{									                                    \
-	struct var *v;				                                        \
-	if (name == NULL)				                                    \
-		return;				                                            \
-	AZ(pthread_mutex_lock(&var_list_mtx));				                \
-	VTAILQ_FOREACH(v, &global_vars, list) {				                \
-		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);				                \
-		AN(v->name);				                                    \
-		if (strcmp(v->name, name) == 0)				                    \
-			break;				                                        \
-	}				                                                    \
-	if (v) {				                                            \
-		VTAILQ_REMOVE(&global_vars, v, list);				            \
-		free(v->name);				                                    \
-		v->name = NULL;				                                    \
-	} else				                                                \
-		ALLOC_OBJ(v, VAR_MAGIC);				                        \
-	AN(v);				                                                \
-	v->name = strdup(name);				                                \
-	AN(v->name);				                                        \
-	VTAILQ_INSERT_HEAD(&global_vars, v, list);				            \
-	if (v->type == STRING)				                                \
-		free(v->value.STRING);				                            \
-	v->value.vcl_type_u = value;				                        \
-	v->type = vcl_type_u;				                                \
-	AZ(pthread_mutex_unlock(&var_list_mtx));				            \
-}
-
-VMOD_GLOBAL_SET_X(INT, int, VCL_INT)
-VMOD_GLOBAL_SET_X(REAL, real, VCL_REAL)
-VMOD_GLOBAL_SET_X(DURATION, duration, VCL_DURATION)
-VMOD_GLOBAL_SET_X(BOOL, bool, VCL_BOOL)
-
-#define VMOD_GLOBAL_GET_X(vcl_type_u, vcl_type_l, ctype)			    \
-ctype									                        \
-vmod_global_get_##vcl_type_l(const struct vrt_ctx *ctx, const char *name)	\
-{									                            \
-	struct var *v;							                    \
-	ctype ret = 0;					                            \
-	if (name == NULL)						                    \
-		return (0);						                        \
-	AZ(pthread_mutex_lock(&var_list_mtx));                      \
-	VTAILQ_FOREACH(v, &global_vars, list) {                     \
-		CHECK_OBJ_NOTNULL(v, VAR_MAGIC);                        \
-		AN(v->name);                                            \
-		if (strcmp(v->name, name) == 0)                         \
-			break;                                              \
-	}                                                           \
-									                            \
-	if (v && v->type == vcl_type_u) 				            \
-		ret = v->value.vcl_type_u;                              \
-    AZ(pthread_mutex_unlock(&var_list_mtx));                    \
-	return ret;					                                \
-}
-
-VMOD_GLOBAL_GET_X(INT, int, VCL_INT)
-VMOD_GLOBAL_GET_X(REAL, real, VCL_REAL)
-VMOD_GLOBAL_GET_X(DURATION, duration, VCL_DURATION)
-VMOD_GLOBAL_GET_X(BOOL, bool, VCL_BOOL)
-
diff --git a/libvmod-revvar-4.0/src/vmod_var.vcc b/libvmod-revvar-4.0/src/vmod_var.vcc
deleted file mode 100644
index 6261008..0000000
--- a/libvmod-revvar-4.0/src/vmod_var.vcc
+++ /dev/null
@@ -1,37 +0,0 @@
-$Module var 3 Variable VMOD for Varnish
-$Init init_function
-# Shortcut for strings
-$Function VOID set(STRING, STRING)
-$Function STRING get(STRING)
-
-# Unset for any
-$Function VOID unset(STRING)
-
-$Function VOID global_set(STRING, STRING)
-$Function STRING global_get(STRING)
-
-$Function VOID global_set_int(STRING, INT)
-$Function INT global_get_int(STRING)
-$Function VOID global_set_real(STRING, REAL)
-$Function REAL global_get_real(STRING)
-$Function VOID global_set_duration(STRING, DURATION)
-$Function DURATION global_get_duration(STRING)
-$Function VOID global_set_bool(STRING, BOOL)
-$Function BOOL global_get_bool(STRING)
-
-$Function VOID set_int(STRING, INT)
-$Function INT get_int(STRING)
-$Function VOID set_string(STRING, STRING)
-$Function VOID set_string_allow_null(STRING, STRING)
-$Function VOID set_string_literal(STRING, STRING)
-$Function STRING get_string(STRING)
-$Function VOID set_real(STRING, REAL)
-$Function REAL get_real(STRING)
-$Function VOID set_duration(STRING, DURATION)
-$Function DURATION get_duration(STRING)
-$Function VOID set_bool(STRING, BOOL)
-$Function BOOL get_bool(STRING)
-$Function BOOL and_or_set_bool(STRING, BOOL)
-$Function BOOL or_or_set_bool(STRING, BOOL)
-
-$Function VOID clear()
-- 
2.7.4

